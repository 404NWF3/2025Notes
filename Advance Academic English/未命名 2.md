// 知识点掌握度建模函数 function calculateKnowledgeWeight(history) { const knowledgeStats = {}; // 初始化知识点统计对象 // 遍历历史记录，带时间衰减的统计 history.forEach((record, index) => { const decay = Math.pow(0.9, history.length - index - 1); // 时间衰减因子 record.knowledge_points.forEach(k => { if (!knowledgeStats[k]) { knowledgeStats[k] = { correct: 0, total: 0 }; // 初始化知识点统计 } knowledgeStats[k].total += decay; // 累加总次数（带衰减） if (record.correct) { knowledgeStats[k].correct += decay; // 累加正确次数（带衰减） } }); }); // 计算知识点权重 const weights = {}; Object.entries(knowledgeStats).forEach(([k, stats]) => { weights[k] = Math.min(1.0, stats.correct / (stats.total + 1e-6)); // 防止除以零 }); return weights; } // 动态难度区间计算函数 function getDynamicDifficulty(history, base = 0.5) { if (history.length === 0) { return [base - 0.1, base, base + 0.1]; // 默认难度区间 } const windowSize = Math.min(10, history.length); // 滑动窗口大小 const lastDiffs = history.slice(-windowSize).map(h => h.difficulty); // 提取最近难度值 const avgDiff = lastDiffs.reduce((a, b) => a + b, 0) / windowSize; // 计算移动平均 // 计算窗口期正确率 const correctCount = history.slice(-windowSize) .filter(h => h.correct).length; const adjust = (correctCount / windowSize - 0.7) * 0.1; // 难度调整因子 return [ Math.max(0.0, avgDiff - 0.2 + adjust), // 最低难度 avgDiff + adjust, // 目标难度 Math.min(1.0, avgDiff + 0.3 + adjust) // 最高难度 ]; } // 核心推荐算法 function generateRecommendations(knowledgeWeights, difficultyRange, questionPool) { const [minDiff, targetDiff, maxDiff] = difficultyRange; const typeWeights = { // 题型权重配置 "选择": 1.0, "填空": 0.9, "解答": 0.8, "综合": 0.7 }; // 筛选和评分流程 return questionPool .filter(q => q.difficulty >= minDiff && q.difficulty <= maxDiff) // 难度过滤 .map(q => { // 计算知识点匹配度 const knowledgeScore = q.knowledge_points .reduce((sum, k) => sum + (1 - (knowledgeWeights[k] || 0)), 0); // 计算难度匹配度 const diffScore = 1 - Math.abs(q.difficulty - targetDiff); // 获取题型权重 const typeWeight = typeWeights[q.type] || 0.6; // 计算综合得分 return { ...q, // 保留题目原始信息 score: 0.6 * knowledgeScore + 0.3 * diffScore + 0.1 * typeWeight }; }) .sort((a, b) => b.score - a.score)